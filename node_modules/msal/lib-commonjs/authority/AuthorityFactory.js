"use strict";
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * @hidden
 */
var AadAuthority_1 = require("./AadAuthority");
var B2cAuthority_1 = require("./B2cAuthority");
var Authority_1 = require("./Authority");
var StringUtils_1 = require("../utils/StringUtils");
var UrlUtils_1 = require("../utils/UrlUtils");
var ClientConfigurationError_1 = require("../error/ClientConfigurationError");
var AuthorityFactory = /** @class */ (function () {
    function AuthorityFactory() {
    }
    /**
     * Use when Authority is B2C and validateAuthority is set to True to provide list of allowed domains.
     */
    AuthorityFactory.setKnownAuthorities = function (validateAuthority, knownAuthorities) {
        if (validateAuthority && !Object.keys(B2cAuthority_1.B2CTrustedHostList).length) {
            knownAuthorities.forEach(function (authority) {
                B2cAuthority_1.B2CTrustedHostList[authority] = authority;
            });
        }
    };
    AuthorityFactory.saveMetadataFromNetwork = function (authorityInstance, telemetryManager, correlationId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var metadata;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, authorityInstance.resolveEndpointsAsync(telemetryManager, correlationId)];
                    case 1:
                        metadata = _a.sent();
                        this.metadataMap.set(authorityInstance.CanonicalAuthority, metadata);
                        return [2 /*return*/, metadata];
                }
            });
        });
    };
    AuthorityFactory.getMetadata = function (authorityUrl) {
        return this.metadataMap.get(authorityUrl);
    };
    AuthorityFactory.saveMetadataFromConfig = function (authorityUrl, authorityMetadataJson) {
        try {
            if (authorityMetadataJson) {
                var parsedMetadata = JSON.parse(authorityMetadataJson);
                if (!parsedMetadata.authorization_endpoint || !parsedMetadata.end_session_endpoint || !parsedMetadata.issuer) {
                    throw ClientConfigurationError_1.ClientConfigurationError.createInvalidAuthorityMetadataError();
                }
                this.metadataMap.set(authorityUrl, {
                    AuthorizationEndpoint: parsedMetadata.authorization_endpoint,
                    EndSessionEndpoint: parsedMetadata.end_session_endpoint,
                    Issuer: parsedMetadata.issuer
                });
            }
        }
        catch (e) {
            throw ClientConfigurationError_1.ClientConfigurationError.createInvalidAuthorityMetadataError();
        }
    };
    /**
     * Parse the url and determine the type of authority
     */
    AuthorityFactory.detectAuthorityFromUrl = function (authorityUrl) {
        authorityUrl = UrlUtils_1.UrlUtils.CanonicalizeUri(authorityUrl);
        var components = UrlUtils_1.UrlUtils.GetUrlComponents(authorityUrl);
        var pathSegments = components.PathSegments;
        if (pathSegments[0] === "adfs") {
            return Authority_1.AuthorityType.Adfs;
        }
        else if (Object.keys(B2cAuthority_1.B2CTrustedHostList).length) {
            return Authority_1.AuthorityType.B2C;
        }
        // Defaults to Aad
        return Authority_1.AuthorityType.Aad;
    };
    /**
     * Create an authority object of the correct type based on the url
     * Performs basic authority validation - checks to see if the authority is of a valid type (eg aad, b2c)
     */
    AuthorityFactory.CreateInstance = function (authorityUrl, validateAuthority, authorityMetadata) {
        if (StringUtils_1.StringUtils.isEmpty(authorityUrl)) {
            return null;
        }
        if (authorityMetadata) {
            // todo: log statements
            this.saveMetadataFromConfig(authorityUrl, authorityMetadata);
        }
        var type = AuthorityFactory.detectAuthorityFromUrl(authorityUrl);
        // Depending on above detection, create the right type.
        switch (type) {
            case Authority_1.AuthorityType.B2C:
                return new B2cAuthority_1.B2cAuthority(authorityUrl, validateAuthority, this.getMetadata(authorityUrl));
            case Authority_1.AuthorityType.Aad:
                return new AadAuthority_1.AadAuthority(authorityUrl, validateAuthority, this.getMetadata(authorityUrl));
            default:
                throw ClientConfigurationError_1.ClientConfigurationError.createInvalidAuthorityTypeError();
        }
    };
    AuthorityFactory.metadataMap = new Map();
    return AuthorityFactory;
}());
exports.AuthorityFactory = AuthorityFactory;
//# sourceMappingURL=AuthorityFactory.js.map